import os
import subprocess
import urllib.request

# Use a `C` program that can emit vpdpbssd assembly to verify that the 
# machine has support to vpdpbssd.
def is_vpdpbssd_supported():
    test_dir = os.path.dirname(__file__)
    c_url = "https://raw.githubusercontent.com/arun-thmn/tpp-mlir/refs/heads/i8-support/tools/check-vpdpbssd.c"
    c_file = os.path.join(test_dir, "check-vpdpbssd.c")
    exe_file = os.path.join(test_dir, "check-vpdpbssd")

    # Download .c file from GitHub raw URL
    try:
        urllib.request.urlretrieve(c_url, c_file)
    except Exception as e:
        return False

    # Compile it
    try:
        subprocess.run(
            ["gcc", "-mavxvnni", "-O2", c_file, "-o", exe_file],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            check=True
        )
    except subprocess.CalledProcessError as e:
        cleanup(c_file, exe_file)
        return False

    # Run it
    try:
        result = subprocess.run([exe_file], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        supported = (result.returncode == 0)
    except Exception as e:
        supported = False

    # Clean up both files
    cleanup(c_file, exe_file)
    return supported

def cleanup(*files):
    for f in files:
        if os.path.exists(f):
             os.remove(f)

def is_arch(target):
    # Arch detection not working on Windows
    if sys.platform in ['win32']:
        return False

    try:
        cmd = subprocess.Popen(
            ['uname', '-m'], stdout=subprocess.PIPE)
    except OSError:
        return False

    out = cmd.stdout.read().decode('ascii')
    cmd.wait()

    return target in out


# Should skip the machine that has no vpdpbssd instruction support
if not is_vpdpbssd_supported():
    config.unsupported = True

# Enable only on x86
# Other targets may use different VNNI blocking scheme that is not compatible with
# prepacked shapes in some of the tests
if not is_arch('x86'):
    config.unsupported = True
